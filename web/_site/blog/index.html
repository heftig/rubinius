<!DOCTYPE html>
<html dir="ltr" lang="en">

  <head>
    <title>Rubinius : Use Ruby&#8482;</title>
  	<meta charset="UTF-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <meta content='en' http-equiv='content-language'>
    <meta content='Rubinius is an implementation of the Ruby programming language. The Rubinius bytecode virtual machine is written in C++. The bytecode compiler is written in pure Ruby. The vast majority of the core library is also written in Ruby, with some supporting primitives that interact with the VM directly.' name='description'>
    <link href='/' rel='home'>
    <link href='/' rel='start'>
    
    
    <link href='/feed/atom.xml' rel='alternate' type='application/atom+xml' title='Rubinius Blog' />
    <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script><![endif]-->
    <script src="/javascripts/jquery-1.3.2.js"></script>
    <script src="/javascripts/paging_keys.js"></script>
    
    <script src="/javascripts/application.js"></script>
    <style>article, aside, dialog, figure, footer, header, hgroup, menu, nav, section { display: block; }</style>

    <link href="/stylesheets/blueprint/screen.css" media="screen" rel="stylesheet" />
    <link href="/stylesheets/application.css"      media="screen" rel="stylesheet" />
    <link href="/stylesheets/blueprint/print.css"  media="print"  rel="stylesheet" />
    <!--[if IE]><link href="/stylesheets/blueprint/ie.css" media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <!--[if IE]><link href="/stylesheets/ie.css"           media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <link href="/stylesheets/pygments.css" media="screen" rel="stylesheet" />

    <link href="/favicon.ico"                 rel="shortcut icon"    type="image/vnd.microsoft.icon" />
    <link href="/images/apple-touch-icon.png" rel="apple-touch-icon" type="image/png" />
    <link href="/images/apple-touch-icon.png" rel="apple-touch-icon" type="image/png" sizes="72x72"   />
    <link href="/images/apple-touch-icon.png" rel="apple-touch-icon" type="image/png" sizes="114x114" />
  </head>

  <body>
    <div class='container'>
  <div class='span-21 blog_menu'>
    <header>
      <nav>
  <ul>
    <li><a href="/">Home</a></li>
    <li><a id="blog" href="/blog">Blog</a></li>
    <li><a id="documentation" href="/doc/en">Documentation</a></li>
    <li><a href="/projects">Projects</a></li>
    <li><a href="/roadmap">Roadmap</a></li>
    <li><a href="/releases">Releases</a></li>
  </ul>
</nav>

    </header>
  </div>

  <div class='span-3 last'>
  <div id='version'>
    <a href="/releases/1.2.4">1.2.4</a>
  </div>
</div>

</div>

    <div class="container posts_nav">
  <nav>
    <a href="/blog/posts_index">Index of Posts</a>
    <a id="feed_icon" href="/feed/atom.xml"><img alt="subscribe" src="/images/feed-icon16x16.png" /></a>
  </nav>
</div>

  <div class="container blog_posts">
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2013/05/21/more-ruby-transparency/" title="Better access to runtime information from Ruby" class="post_title">
        Better access to runtime information from Ruby
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Dirkjan Bussink</span>
    <span class="date">21 May 2013</span>
    
      <a href="http://rubini.us/2013/05/21/more-ruby-transparency/#disqus_thread" data-disqus-identifier="/2013/05/21/more-ruby-transparency/"></a>

    
  </p>
</div>

      <p>Rubinius has always tried to provide a lot of information to you as a
developer about runtime information. Things like the variable scope and
constant scope are already available. In this post I’d like to describe
a small new API that is available for even more information.</p>

<h3 id="inline-caching">Inline caching</h3>

<p>One of the important mechanisms in making your Ruby code fast is doing
inline caching. Inline caching means that we store the result of a method
lookup a specific call site.</p>

<p>So what is a call site you might ask? Well, that’s every place in your
code where a method is called. So take for example the following
snippet.</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="k">class</span> <span class="nc">Foo</span>
<span class="lineno">2</span>   <span class="k">def</span> <span class="nf">bar</span>
<span class="lineno">3</span>     <span class="vi">@foo</span><span class="o">.</span><span class="n">quz</span>
<span class="lineno">4</span>   <span class="k">end</span>
<span class="lineno">5</span> <span class="k">end</span>
</code></pre></div>

<p>Here <code>@foo.quz</code> is a call site, so the place where quz is called. What we
do here is cache the type of <code>@foo</code> and store which method to execute for
this type.</p>

<p>The fact that inline caching works well is based on the idea that at
runtime for most call sites the receiver type never changes. So in this
case it means that <code>@foo</code> is always of the same type. This is
called a monomorphic call site. </p>

<p>Of course there are cases where this reasoning doesn’t apply. If we see
multiple types at a certain call site, it’s called a polymorphic call site.
For this we store things in a different object and Rubinius currently stores
up to 3 different types in that case.</p>

<p>It might be surprising to some, but these cache objects are also just
Ruby objects. This means that they can be used just like any other Ruby
object and be inspected for example. So there are objects for an empty
call site, for monomorphic and also polymorphic sites.</p>

<p>There is also a specialized site for places where we call <code>respond_to?</code> since that
happens often enough to warrant a special case. In the future there
might be new types introduced such as a specific type for <code>send</code> calls.</p>

<h3 id="accessing-inline-caches-stored-at-call-sites">Accessing inline caches stored at call sites</h3>

<p>So now that we have described all this, how do we get access to this
information? It is actually pretty straightforward and builds on other
things already available.</p>

<p>Under the hood, all Ruby code in Rubinius gets translated into a
<code>CompiledCode</code> object, which also provides the API for getting access to
inline caches. One way to get access to the <code>CompiledCode</code> object is to
grab it through Ruby’s Method API.</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">Foo</span>
<span class="lineno"> 2</span>   <span class="k">def</span> <span class="nf">bar</span>
<span class="lineno"> 3</span>     <span class="vi">@foo</span><span class="o">.</span><span class="n">quz</span>
<span class="lineno"> 4</span>   <span class="k">end</span>
<span class="lineno"> 5</span> <span class="k">end</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="n">f</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
<span class="lineno"> 8</span> <span class="n">compiled_code</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="ss">:bar</span><span class="p">)</span><span class="o">.</span><span class="n">executable</span>
<span class="lineno"> 9</span> <span class="n">compiled_code</span><span class="o">.</span><span class="n">call_sites</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">cs</span><span class="o">|</span>
<span class="lineno">10</span>   <span class="nb">p</span> <span class="n">cs</span> <span class="c1"># #&lt;Rubinius::CallSite:0xXX script.rb:3#quz(0)&gt;</span>
<span class="lineno">11</span> <span class="k">end</span>
</code></pre></div>

<p>What you can see here is that we have one call site located at <code>script.rb</code>
on line 3 (which is the class definition). Currently it’s of the type
<code>CallSite</code>, which means that it has a basic structure in place with no
additional information because this method was never called. This can
also be inferred from the (0) at the end which indicates the number of
calls through this object.</p>

<p>So if we make sure we call this at least once, we should be able to see
this information.</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">Foo</span>
<span class="lineno"> 2</span>   <span class="k">def</span> <span class="nf">bar</span>
<span class="lineno"> 3</span>     <span class="vi">@foo</span><span class="o">.</span><span class="n">quz</span>
<span class="lineno"> 4</span>   <span class="k">end</span>
<span class="lineno"> 5</span> <span class="k">end</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="n">f</span> <span class="o">=</span> <span class="no">Foo</span><span class="o">.</span><span class="n">new</span>
<span class="lineno"> 8</span> <span class="k">begin</span>
<span class="lineno"> 9</span>   <span class="n">f</span><span class="o">.</span><span class="n">bar</span>
<span class="lineno">10</span> <span class="k">rescue</span>
<span class="lineno">11</span> <span class="k">end</span>
<span class="lineno">12</span> 
<span class="lineno">13</span> <span class="n">compiled_code</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="ss">:bar</span><span class="p">)</span><span class="o">.</span><span class="n">executable</span>
<span class="lineno">14</span> <span class="n">compiled_code</span><span class="o">.</span><span class="n">call_sites</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">cs</span><span class="o">|</span>
<span class="lineno">15</span>   <span class="nb">p</span> <span class="n">cs</span> <span class="c1"># #&lt;Rubinius::MonoInlineCache:0xXX script.rb:3#quz(1)</span>
<span class="lineno">16</span>        <span class="c1">#   receiver_class=NilClass stored_module=Kernel</span>
<span class="lineno">17</span>        <span class="c1">#   method=#&lt;Rubinius::CompiledCode method_missing file=kernel/delta/kernel.rb&gt;&gt;</span>
<span class="lineno">18</span> <span class="k">end</span>
</code></pre></div>

<p>What we do here is actually run this inside a begin / rescue clause
because the call will fail because @foo being nil. But this will also
show that we can actually cache that this will run the <code>method_missing</code>
method and that we cache that.</p>

<p>What you can see here is that we have a <code>MonoInlineCache</code>, because we’ve
only seen one type for <code>@foo</code>, which is <code>nil</code> so the receiver class is
<code>NilClass</code>. The <code>stored_module</code> is the module the saved method is in, which
in this case is <code>Kernel</code>. The actual method stored is the <code>method_missing</code>
method here. We can also see it has been called 1 time so far.</p>

<h3 id="caveats">Caveats</h3>

<p>Currently you get these objects back and you can actually modify them.
Modifying them at the moment would actually result in undefined
behavior. You can’t do this easily though since they only provide
accessor readers, but since it’s Ruby you can of course hack around with
<code>instance_variable_set</code> for example.</p>

<p>You can probably do really crazy stuff with this, if it crashes the vm
it’s probably a bug, otherwise you’re pretty much on your own when
hacking this.</p>

<p>Another thing is that the counters are not guaranteed to be accurate.
This can mainly happen when the JIT kicks in. The JIT doens’t update
counters if it inlines methods so that way the method could be called
more often than you’d think based on the counter. If it’s zero though,
you can be sure it has been never called since it will always go through
the interpreter path first.</p>

<h3 id="future">Future</h3>

<p>So besides for fun and crazy, what is this actually useful for? Well,
first of all we already use it to actually test in Ruby whether our
inline caches work properly. This made testing this a lot easier and we
can easily verify that an empty call sites turns into a monomorphic
cache and subsequently in a polymorphic one if needed.</p>

<p>Another reason this can be very useful is for building better tools.
With this information, it would be possible to create better
refactoring tools for example. The information provided here gives you
insight into which methods are bound where and could help perhaps in
renaming things.</p>

<p>It would also be interesting to gather this information from your
runtime application, so you could see which code does and doesn’t get
executed in your production environment. All these things are just
ideas, but API’s like the one discussed here make these future
developments possible and allow for more insight in your Ruby code.</p>

<p>So play with and let us know what you’ve done with it!</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2013/03/20/profiling-jitted-ruby-code-with-oprofile/" title="Profiling JIT-ted Ruby code with OProfile" class="post_title">
        Profiling JIT-ted Ruby code with OProfile
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Ryo Onodera</span>
    <span class="date">20 March 2013</span>
    
      <a href="http://rubini.us/2013/03/20/profiling-jitted-ruby-code-with-oprofile/#disqus_thread" data-disqus-identifier="/2013/03/20/profiling-jitted-ruby-code-with-oprofile/"></a>

    
  </p>
</div>

      <p>You can now profile JIT-ted Ruby code!</p>

<p>Before:</p>

<pre><code>samples  %        linenr info                 app name                 symbol name
497      28.7117  instructions.cpp:82         rbx                      rubinius::MachineCode::interpreter(rubinius::State*, rubinius::MachineCode*, rubinius::InterpreterCallFrame*)
460      26.5742  (no location information)   anon (tgid:4118 range:0xb581c000-0xb589c000) anon (tgid:4118 range:0xb581c000-0xb589c000)
  # =&gt; The dark world of JIT-ted Ruby code
158       9.1277  jit_util.cpp:787            rbx                      rbx_set_local_depth
113       6.5280  block_environment.cpp:365   rbx                      rubinius::BlockEnvironment::call(rubinius::State*, rubinius::CallFrame*, rubinius::Arguments&amp;, int)
102       5.8925  (no location information)   rbx                      __x86.get_pc_thunk.bx
93        5.3726  jit_util.cpp:848            rbx                      rbx_push_local_depth
71        4.1017  variable_scope.cpp:108      rbx                      rubinius::VariableScope::set_local(int, rubinius::Object*)
68        3.9284  block_environment.cpp:62    rbx                      rubinius::BlockEnvironment::invoke(rubinius::State*, rubinius::CallFrame*, rubinius::BlockEnvironment*, rubinius::Arguments&amp;, rubinius::BlockInvocation&amp;)
52        3.0040  variable_scope.cpp:126      rbx                      rubinius::VariableScope::get_local(int)
47        2.7152  variable_scope.cpp:100      rbx                      rubinius::VariableScope::set_local(rubinius::State*, int, rubinius::Object*)
45        2.5997  kind_of.hpp:153             rbx                      bool rubinius::kind_of&lt;rubinius::Fiber&gt;(rubinius::Object const*)
24        1.3865  shared_state.cpp:295        rbx                      rubinius::SharedState::checkpoint(rubinius::ManagedThread*)
</code></pre>

<p>After:</p>

<pre><code>samples  %        linenr info                 app name                 symbol name
3468     27.0388  instructions.cpp:82         rbx                      rubinius::MachineCode::interpreter(rubinius::State*, rubinius::MachineCode*, rubinius::InterpreterCallFrame*)
3048     23.7642  loop.rb:7                   5060.jo                  _X_Object#forever$block@1
  # =&gt; Wow, the name of JIT-ted Ruby code is shown along side C++ function symbols!
1044      8.1397  jit_util.cpp:848            rbx                      rbx_push_local_depth
947       7.3834  (no location information)   rbx                      __x86.get_pc_thunk.bx
916       7.1417  jit_util.cpp:787            rbx                      rbx_set_local_depth
781       6.0892  block_environment.cpp:365   rbx                      rubinius::BlockEnvironment::call(rubinius::State*, rubinius::CallFrame*, rubinius::Arguments&amp;, int)
639       4.9821  block_environment.cpp:62    rbx                      rubinius::BlockEnvironment::invoke(rubinius::State*, rubinius::CallFrame*, rubinius::BlockEnvironment*, rubinius::Arguments&amp;, rubinius::BlockInvocation&amp;)
421       3.2824  variable_scope.cpp:108      rbx                      rubinius::VariableScope::set_local(int, rubinius::Object*)
389       3.0329  variable_scope.cpp:126      rbx                      rubinius::VariableScope::get_local(int)
326       2.5417  variable_scope.cpp:100      rbx                      rubinius::VariableScope::set_local(rubinius::State*, int, rubinius::Object*)
288       2.2454  shared_state.cpp:295        rbx                      rubinius::SharedState::checkpoint(rubinius::ManagedThread*)
283       2.2065  kind_of.hpp:153             rbx                      bool rubinius::kind_of&lt;rubinius::Fiber&gt;(rubinius::Object const*)
</code></pre>

<p>In short, you can tell how the machine code that the Rubinius JIT generates
performs.</p>

<p>Not satisfied yet? Even annotated profile is supported! That means you can even
know how much time it spends on each line of Ruby code or even on each CPU
instruction:</p>

<pre><code>/* 
 * Total samples for file : "/tmp/loop.rb"
 * 
 *   5658 19.9436
 */


   718  2.5308 :def increment(i)
   482  1.6990 :  i + 1
               :end
               :
               :def forever
               :  i = 0
  2933 10.3384 :  loop do /* _X_Object#forever$block@1 total:   6990 24.6387 */
  1525  5.3754 :    i = increment(i)
               :  end
               :end
               :
               :forever
</code></pre>

<p>We’re using <a href="http://oprofile.sourceforge.net/news/">OProfile</a>, a profiling
software. In this blog post, I’ll show you how to profile using it!</p>

<h3 id="whats-oprofile">What’s OProfile?</h3>

<p>It’s a very useful profiling tool available on Linux. It’s a sampling-based
one. That means there is absolutely no change to Rubinius and your Ruby code to
profile. Just run it as you normally do. Also, the overhead of profiling is
minimal.</p>

<p>This is contrasted to measuring-based profiling. Rubinius’s built-in profiler
and ruby-prof are both examples of measuring profilers. This means the overhead
is much bigger and can skew results because of that.</p>

<p>Basically, it works by reporting how many individual profiled items are sampled
compared to the overall total samples. It doesn’t measure elapsed time. It’s
much like top command’s individual processes’ CPU % usage with far greater
flexibility. The actual profiled items can be any of C/C++ libraries, C/C++
functions, C/C++ source code lines, or CPU instructions.</p>

<p>So, OProfile can’t usually profile Ruby code because it works on CPU
instruction level. From OProfile, it can’t tell which Ruby source code line
Rubinius currently executing from the CPU instructions. However, it can profile
JIT-ted Ruby code because Rubinius compiles it very down into the CPU
instructions by definition.</p>

<p>OProfile works as a Linux kernel module. So, it’s supported only for Linux.
Sadly, Ubuntu’s OProfile and LLVM have bugs relating to this feature.
Apparently, there is no one using this. So you can say, we are really on the
cutting edge. ;)</p>

<p>Anyway, we must work around these problems. But how? There are a few options.
:)</p>

<h3 id="setup-ppa-the-super-simple-way-ubuntu-1210-only">Setup (PPA: the super simple way; Ubuntu 12.10 only)</h3>

<p>I prepared a <a href="https://launchpad.net/~ryoqun/+archive/ppa">PPA</a> just for you.
Add it to your system. To be specific, run this:</p>

<pre><code>$ sudo add-apt-repository ppa:ryoqun/ppa
$ sudo apt-get update
$ sudo apt-get install oprofile llvm-3.1
$ sudo apt-get dist-upgrade # Upgrade preinstalled libllvm3.1 to the PPA
</code></pre>

<p>By default, Rubinius doesn’t use system-provided LLVM, so re-configure Rubinius
to use it and re-build Rubinius:</p>

<pre><code>$ cd /path/to/rubinius-git-repository
$ rake clean
$ ./configure --llvm-config llvm-config-3.1
$ rake
</code></pre>

<p>Done!</p>

<h3 id="setup-manual-build-the-hard-way">Setup (manual build: the hard way)</h3>

<p>If you really want to build LLVM and OProfile manually or if you’re using an
other Linux distribution and the distribution doesn’t provide OProfile-enabled
 LLVM packages, manually build LLVM and OProfile like this:</p>

<p>(I tested this on Ubuntu 12.10. Minor adjustments may be needed to build on
your environment)</p>

<p>Build and Install OProfile:</p>

<pre><code>$ sudo apt-get build-dep oprofile # do equivalent thing on your distro.
$ cd /path/to/working-dir-to-build-things
$ wget http://prdownloads.sourceforge.net/oprofile/oprofile-0.9.8.tar.gz
$ tar -xf oprofile-0.9.8.tar.gz
$ cd oprofile-0.9.8
$ ./autogen.sh
$ ./configure --prefix /usr # LLVM has a build issue. So install to /usr
$ make
$ sudo make install
$ adduser oprofile # this is needed for profiling JITted code
$ opreport --version
  # =&gt; opreport: oprofile 0.9.8 compiled on Mar  8 2013 00:57:08
</code></pre>

<p>Build LLVM with OProfile support enabled and rebuild Rubinius:</p>

<pre><code>$ sudo apt-get build-dep llvm # do equivalent thing on your distro.
$ cd /path/to/working-dir-to-build-things
$ wget http://llvm.org/releases/3.2/llvm-3.2.src.tar.gz
$ tar -xf llvm-3.2.src.tar.gz
$ cd llvm-3.2.src
$ ./configure --enable-optimized --disable-assertions --with-oprofile
$ make
$ sudo make install
</code></pre>

<p>If the compilation of <code>OProfileWrapper.cpp</code> fails like this:</p>

<pre><code>OProfileWrapper.cpp: In member function ‘bool llvm::OProfileWrapper::checkForOProfileProcEntry()’:
OProfileWrapper.cpp:141:62: error: ‘read’ was not declared in this scope
OProfileWrapper.cpp:142:24: error: ‘close’ was not declared in this scope
</code></pre>

<p>Apply this patch, then, re-<code>make</code> and continue:</p>

<pre><code>diff --git a/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp b/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
index d67f537..7c0d395 100644
--- a/llvm-3.1-3.1/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
+++ b/llvm-3.1-3.1/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp
@@ -29,6 +29,7 @@
 #include &lt;dirent.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
 
 namespace {
</code></pre>

<p>Phew, finally rebuild Rubinius!:</p>

<pre><code>$ cd /path/to/rubinius-git-repository
$ rake clean
$ rm -rf vendor/llvm # If you build Rubinius with vendorized LLVM.
$ ./configure
$ rake
</code></pre>

<h3 id="start-oprofile">Start OProfile</h3>

<p>OProfile can be configured by a command called <code>opcontrol</code>, not by a
configuration file, which are common.</p>

<pre><code>$ sudo opcontrol --deinit
$ sudo modprobe oprofile timer=1      # Needed only inside VirtualBox VMs
$ echo 0 | sudo tee /proc/sys/kernel/nmi_watchdog
$ sudo opcontrol --no-vmlinux
$ sudo opcontrol --separete all
$ sudo opcontrol --start
$ sudo opcontrol --dump               # Flushes buffered raw profile data
$ opreport --merge all --threshold 1  # Prints the report of profile
</code></pre>

<p>Setup is complete if you see an output from <code>opreport</code> like this:</p>

<pre><code>CPU: CPU with timer interrupt, speed 1858.39 MHz (estimated)
Profiling through timer interrupt
          TIMER:0|
  samples|      %|
------------------
    92127 67.6157 no-vmlinux
    21920 16.0880 rbx
     7950  5.8348 libc-2.15.so
     4068  2.9857 runner
     3429  2.5167 libstdc++.so.6.0.17
     2139  1.5699 cc1
     1416  1.0393 vm
</code></pre>

<p>Congratulations!</p>

<h3 id="run-ruby-code">Run Ruby code!</h3>

<p>To annotate Ruby code correctly, your current directory must be the top
directory of the Rubinius git repository:</p>

<pre><code>$ cd /path/to/rubinius-git-repository
$ ./bin/benchmark ./benchmark/core/hash/bench_access.rb
</code></pre>

<h3 id="generate-profile-report">Generate profile report</h3>

<p>Let’s check the profile report of the above benchmark.</p>

<p>NOTE: try to run <code>opcontrol --dump</code> at least once while running Rubinius if
JIT-ted Ruby code doesn’t show in the profile report. OProfile automatically
dumps periodically, but if your Ruby process terminates too quickly, you
should manually run <code>opcontrol --dump</code> while it’s still alive.</p>

<pre><code>$ sudo opcontrol --dump &amp;&amp; sudo opjitconv /var/lib/oprofile/ 0 0
$ opreport --merge all --threshold 1 image:./bin/rbx --symbols --debug-info \
    &gt; /tmp/hash-access-symbols
$ opannotate --merge all --threshold 0.5 image:./bin/rbx --source \
    &gt; /tmp/hash-access-source
</code></pre>

<p>I’ll omit but you can generate profile report of annotated assembly by passing
<code>--assembly</code> to <code>opannotate</code> instead of <code>--source</code>.</p>

<h3 id="reset-current-profile">Reset current profile</h3>

<p>By default, OProfile keeps the profile data indefinitely. To reset it, run
this:</p>

<pre><code>$ sudo opcontrol --reset
</code></pre>

<h3 id="how-to-read-the-profile-result">How to read the profile result</h3>

<p>Open <code>/tmp/hash-access-symbols</code>, the content should be like this:</p>

<pre><code>CPU: CPU with timer interrupt, speed 1860.42 MHz (estimated)
Profiling through timer interrupt
samples  %        linenr info                 app name                 symbol name
3571     31.5990  (no location information)   no-vmlinux               /no-vmlinux
619       5.4774  bench_access.rb:16          8295.jo                  _X_Object#__block__$block@7
599       5.3004  bench_access.rb:24          8295.jo                  _X_Object#__block__$block@11
531       4.6987  bench_access.rb:8           8295.jo                  _X_Object#__block__$block@1
457       4.0439  (no location information)   rbx                      __x86.get_pc_thunk.bx
318       2.8139  jit_util.cpp:787            rbx                      rbx_set_local_depth
298       2.6369  bench_access.rb:42          8295.jo                  _X_Object#__block__$block@20
277       2.4511  object.cpp:362              rbx                      rubinius::Object::hash(rubinius::State*)
236       2.0883  jit_primitives.cpp:4494     rbx                      jit_stub_object_hash
236       2.0883  tuple.cpp:36                rbx                      rubinius::Tuple::put(rubinius::State*, int, rubinius::Object*)
222       1.9644  inline_cache.cpp:696        rbx                      rubinius::InlineCache::check_cache_poly(rubinius::State*, rubinius::InlineCache*, rubinius::CallFrame*, rubinius::Arguments&amp;)
197       1.7432  jit_util.cpp:848            rbx                      rbx_push_local_depth
187       1.6547  variable_scope.cpp:126      rbx                      rubinius::VariableScope::get_local(int)
179       1.5839  compiledcode.cpp:212        rbx                      rubinius::CompiledCode::specialized_executor(rubinius::State*, rubinius::CallFrame*, rubinius::Executable*, rubinius::Module*, rubinius::Arguments&amp;)
162       1.4335  hash.rb:220                 8295.jo                  _X_Hash#key_index@15
147       1.3008  hash.rb:325                 8295.jo                  _X_Hash#values_at$block@13
143       1.2654  object.cpp:400              rbx                      rubinius::Object::hash_prim(rubinius::State*)
137       1.2123  (no location information)   libc-2.15.so             /lib/i386-linux-gnu/libc-2.15.so
127       1.1238  variable_scope.cpp:100      rbx                      rubinius::VariableScope::set_local(rubinius::State*, int, rubinius::Object*)
111       0.9822  inline_cache.cpp:576        rbx                      rubinius::InlineCache::check_cache_reference(rubinius::State*, rubinius::InlineCache*, rubinius::CallFrame*, rubinius::Arguments&amp;)
108       0.9557  vm.cpp:175                  rbx                      rubinius::VM::new_object_typed_dirty(rubinius::Class*, unsigned int, rubinius::object_type)
99        0.8760  vm.cpp:207                  rbx                      rubinius::VM::new_young_tuple_dirty(unsigned int)
97        0.8583  array18.rb:6                8295.jo                  _X_Array#map@12
93        0.8229  integer.cpp:84              rbx                      rubinius::Integer::from(rubinius::State*, int)
90        0.7964  hash.rb:137                 8295.jo                  _X_Hash#[]@23
76        0.6725  array.cpp:205               rbx                      rubinius::Array::set(rubinius::State*, int, rubinius::Object*)
72        0.6371  linkedlist.cpp:27           rbx                      LinkedList::remove(LinkedList::Node*)
68        0.6017  tuple.cpp:64                rbx                      rubinius::Tuple::create(rubinius::State*, int)
57        0.5044  method_primitives.cpp:12327 rbx                      rubinius::Primitives::object_hash(rubinius::State*, rubinius::CallFrame*, rubinius::Executable*, rubinius::Module*, rubinius::Arguments&amp;)
</code></pre>

<p>As you can guess, symbol names beginning with <code>_X_</code> is the JIT-ted Ruby code.
Many Ruby benchmark blocks are JIT-ted (like
<code>_X_Object#__block__$block@7</code> at <code>bench_access.rb:16</code>) and listed near the top.
Also, <code>_X_Array#map@12</code> is a JIT-ted code of <code>Array#map</code>. I’ll explain the
format of the report using it as an example:</p>

<pre><code>97        0.8583  array18.rb:6                8295.jo                  _X_Array#map@12
</code></pre>

<p><code>97</code> is the number of counts OProfile found what Rubinius was executing, while
periodically sampling it.</p>

<p><code>0.8583</code> is the percentage to the total number of samples OProfile collected.
Note that summing all entries up doesn’t equal to 100%, because <code>opreport</code> only
reported the top part of whole profile result (by <code>--threshold 0.5</code>).</p>

<p><a href="https://github.com/rubinius/rubinius/blob/1d7d7b2e2880478776476089d4dd93fd97aff122/kernel/bootstrap/array18.rb#L6"><code>array18.rb:6</code></a>
is the source location where this method is defined (this is same as
<code>Method#source_location</code>).</p>

<p><code>8295.jo</code> is a special <code>app name</code> for JIT-ted code. Usually <code>app name</code> is the
name of file C/C++ functions reside in (shared libraries or executables).
So, for normal Rubinius’ C++ functions, <code>app name</code> is just <code>rbx</code> because they
reside in <code>./bin/rbx</code>. For JIT-ted Ruby code, there can be no meaningful <code>app
name</code>, because JIT-ted Ruby code is generated at runtime and they reside in no
file, but only in memory. So, OProfile uses <code>*.jo</code> as <code>app name</code> in such cases.
And, <code>8295</code> means this is profiled when running the process of PID 8295.</p>

<p><code>_X_Array#map@12</code> is the name of symbol for this entry of profile report
(duh!).</p>

<p>Open <code>/tmp/hash-access-source</code>, the content should be like this (I’ll omit some
unimportant part, because this file is big):</p>

<pre><code>/* 
 * Total samples for file : "kernel/common/hash18.rb"
 * 
 *   4870 12.8904
 */

&lt;credited to line zero&gt;     19  0.0503 :
               :# -*- encoding: us-ascii -*-
               :
               :class Hash
               :
               :  include Enumerable
               :
...
               :
               :  class Bucket
               :    attr_accessor :key
               :
   633  1.6755 :    def match?(key, key_hash) /* _X_Hash::Bucket#match?@16     75  0.1985, _X_Hash::Bucket#match?@16     45  0.1191, total:    120  0.3176 */
    40  0.1059 :      case key
   218  0.5770 :      when Symbol, Fixnum
   319  0.8444 :        return key.equal?(@key)
               :      end
               :
               :      @key_hash == key_hash and (Rubinius::Type::object_equal(key, @key) or key.eql?(@key))
               :    end
               :  end
...
               :end
...
</code></pre>

<p>You might wonder why <code>Hash::Bucket#match?</code> has so many counts while this didn’t
appear in the report for symbols. The reason is that the method is inlined to
each its callers (maybe many top-appearing JIT-ted Ruby blocks). How cool this
is! You can really know which Ruby code is actually taking too much time.</p>

<h3 id="my-last-favor">My last favor</h3>

<p>I wish the official Ubuntu packages are fixed and there is no need to add any
PPA. I want it-just-works. I reported affecting bugs to Ubuntu’s bug tracking
system. So, please vote it up for fixing (vote them with “affects you?”,
please!!):</p>

<ul>
  <li><a href="https://launchpad.net/bugs/1154025">Bug 1154025</a> Install PIC version of libbfd.a</li>
  <li><a href="https://launchpad.net/bugs/1148682">Bug 1148682</a> symbol lookup error: /usr/lib/libopagent.so: undefined symbol: bfd_init</li>
  <li><a href="https://launchpad.net/bugs/1148529">Bug 1148529</a> OProfile support is disabled</li>
</ul>

<h3 id="further-profiling">Further profiling</h3>

<p>There is new profiling tool on Linux: <code>perf</code> and <code>operf</code> (OProfile’s new
command). I don’t know them well, but certainly they will be useful for
profiling Rubinius.</p>

<p>As a last note, this is partially based on <a href="http://code.google.com/p/unladen-swallow/wiki/UsingOProfile">Unladen Swallow’s
information</a>
of profiling LLVM-based JIT-ted code by OProfile.</p>

<p>Happy profiling!</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2013/03/19/pdx-summit-recap/" title="PDX Summit Recap" class="post_title">
        PDX Summit Recap
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Brian Shirai</span>
    <span class="date">19 March 2013</span>
    
      <a href="http://rubini.us/2013/03/19/pdx-summit-recap/#disqus_thread" data-disqus-identifier="/2013/03/19/pdx-summit-recap/"></a>

    
  </p>
</div>

      <p>Last week, Dirkjan spent the week with me at the Engine Yard office in
Portland, OR. We wanted to discuss a variety of topics related to Rubinius
technology. We started the week by making the following list:</p>

<ul>
  <li>Inline cache</li>
  <li>JIT IR</li>
  <li>Performance of JIT’d code</li>
  <li>Extension API</li>
  <li>Concurrency and garbage collection</li>
</ul>

<p>We spent the week mostly writing a ton of things on the whiteboard, discussing
them, erasing them, and writing a bunch more. Ultimately, we touched on all
the topics but we did not get to discussing the extension API in depth, so
we’ll skip that one for now. I’ve <a href="http://rubini.us/2013/03/13/welcome-dirkjan/">previously
blogged</a> about our inline cache
discussion. Here I’ll summarize the rest of our discussions.</p>

<h2 id="just-in-time-compiler">Just-in-time Compiler</h2>

<p>The just-in-time (JIT) compiler that converts our virtual machine bytecode to
machine code is a fundamental part of making Ruby fast. It is also one of the
most complex components of Rubinius. It requires interfacing with the virtual
machine to get runtime data and coordinating with the garbage collector to
keep other runtime data structures consistent.</p>

<p>We are able to leverage <a href="http://llvm.org">LLVM</a> for especially difficult parts
of machine code generation, like instruction selection, instruction scheduling
and register allocation. However, the semantics of Ruby are so removed from
those of the underlying CPU that we have a lot of work we still need to do to
improve the quality of the machine code.</p>

<p>One important component of this work is the ability to represent operations
that have Ruby semantics (but are not part of Ruby itself) in a way that we
can perform transformations on those operations. The “not part of Ruby” is
actually a bit fuzzy. The concept of object allocation is certainly a part of
Ruby. But the specific operation of reserving a region in the heap is
invisible to Ruby.</p>

<p>There are a couple operations in particular that are critical to Ruby
performance, especially when emitting machine code from the JIT. Those
operations are type guards and object allocation. If our assumptions for the
particular type of a value hold, we want to emit the fewest number of guards
as possible and we want the largest contiguous sequence of machine
instructions that are valid under a specific guard.</p>

<p>Likewise, if an object is allocated but does not get passed outside of the
code sequence we are compiling to machine code, and we can see there are no
other side effects, we may be able to avoid allocating the object. A good
example of this in Rubinius, where the core library is implemented in Ruby, is
the ByteArray object that is used by String. A ByteArray is a fixed vector of
8-bit bytes. If an intermediate operation on a String creates a ByteArray and
that object isn’t used outside the JIT’d method, the JIT should be able to see
through the object creation and recognize that just some machine bytes are
being moved around or transformed. The ByteArray allocation can be elided.</p>

<p>These two examples, type guards and object allocation, are just a couple
things we expect the JIT to do well. There are many others.</p>

<p>Right now, our JIT converts the virtual machine bytecode directly into LLVM
IR. To support more sophisticated JIT transformations, we need a
representation in between bytecode and LLVM IR, which is one of the things we
will be working on.</p>

<p>Another aspect of the JIT that needs an overhauls is the infrastructure around
running the JIT. It runs on a separate native thread with few synchronization
points. Since Rubinius has no global lock, and since we need a variety of
auxiliary threads for system operations (e.g. handling process signals,
running object finalizers, handling debugger events), we have some
infrastructure for handling the lifetimes of these auxiliary threads. This is
a particularly complicated aspect of Rubinius because when Ruby code calls
<code>fork()</code> or <code>exec()</code>, the Ruby code knows nothing about these auxiliary
threads. We have to be careful that state is maintained across these calls.
This component will be enhanced to better handle auxiliary threads that are
actually proper Ruby threads (all auxiliary threads are fundamentally Ruby
threads but not necessarily visible in Ruby). This will permit us to have
multiple, potentially completely different, JIT threads running
simultaneously.</p>

<h2 id="performance">Performance</h2>

<p>For us as people, when our assumptions fail we often just blunder on making
fools of ourselves. Too bad we don’t have a “check your assumptions” mode as
useful as the one we build into the JIT. In the JIT, if our assumptions fail
and we don’t catch it, we’re going to compute the wrong values or cause the
wrong actions to be performed.</p>

<p>So, in the JIT, when our assumptions are wrong, we must change course. This
course change may be to go down a different path in the machine code or to
exit the machine code entirely and go back to the interpreter. Both paths have
significant performance implications.</p>

<p>A reason to exit the machine code is that one significant aspect of generating
fast machine code is proper use of the type guards. If our assumptions about
the type of a value are wrong, simply exiting back to the interpreter means
that we don’t pollute the LLVM IR with types that can inhibit LLVM
optimizations from being as effective. On the other hand, there are runtime
costs associated with both exiting to the interpreter and running the
interpreter instead of machine code. Also, if we exit the generate machine code
too often, we may trigger a de-opt, throwing away that version of the machine
code and requiring the JIT to create a new one.</p>

<p>Another aspect of the performance of the machine code we emit is how we handle
virtual machine operations. Some aspects of running Ruby require very
low-level operations that we call primitives. These are coded in C++ and
interact with internal virtual machine facilities. When compiling machine
code, we want as few conditionals and as few function calls as possible to get
the highest performance. Typically, we call a function that performs the
primitive operation and then returns to the JIT’d machine code. As we move
more and more things into Ruby itself, it is possible for the JIT to inline
operations and get the greatest possible optimizations. This is another area
we will be working on as we improve the JIT.</p>

<h2 id="concurrency">Concurrency</h2>

<p>One of the goals for Rubinius since the very beginning is to provide excellent
support for concurrency and parallelism in Ruby. We have already removed the
global interpreter lock (GIL/GVL) from Rubinius. However, we have to ensure
that we don’t replace it with an effective global lock when we implement
components of the system.</p>

<p>The key to improving lock-freedom throughout the system is to use less locks.
That may seem obvious, but it is not necessarily that simple. As I mentioned
above, the virtual machine actually uses a variety of threads internally. And
with no global lock, any Ruby thread could invoke any virtual machine
operation, like <code>fork()</code>, at any time. Multiple Ruby threads could be calling
the same method on the same object at the same time. Considering my previous
post about inline caches, this implies that all sorts of data races and
concurrency bugs could arise just from calling Ruby methods.</p>

<p>In the virtual machine, we must be careful to ensure correctness under
concurrent execution. The classical way of doing so is to use locking.
However, there is tons of research from the ’90s about lock-free and wait-free
algorithms. This academic research is slowly trickling down to industry in
various domains. We will be using lock-free implementations of various virtual
machine data structures to improve support for concurrency and parallelism.</p>

<h2 id="garbage-collection">Garbage Collection</h2>

<p>One particularly challenging area that requires careful control of concurrency
is the garbage collector. Rubinius provides a generational garbage collector
with very short pause times when collecting the young generation. The
generational architecture allows us to only collect a small region of the heap
instead of the whole heap every time. We also support object allocation using
thread-local buffers to avoid locking and contention when Ruby code is running
in parallel.</p>

<p>However, the garbage collector architecture pauses all threads to perform a
collection. While the pause for a young generation collection is on the order
of a few milliseconds (5-15 in many cases), there is the overhead of forcing
all the various threads to pause.</p>

<p>There is only one way to address this issue and that is to make the garbage
collector concurrent. Fortunately, we can achieve this with some modifications
to our existing garbage collector. When adding concurrency to the garbage
collector, we want to avoid slowing down non-garbage-collector operations,
typically referred to as mutator performance. (Operations in the system can be
viewed as partitioned into two sets: the heap management–allocation and
garbage collection, and the operations that mutate the heap–mutator
operations.)</p>

<p>With modifications to our mature generation collector (based on the Immix
collector), we can perform partial heap collections and preserve the
generational benefits while also limiting stop-the-world pauses to specific
regions of the heap and bounding the pause times.</p>

<h2 id="semantic-versioning">Semantic Versioning</h2>

<p><a href="http://semver.org/">Semantic Versioning</a> is a methodology for versioning
software to support correct dependency management. MRI has never had
particularly strong support for versioning, with semantic changes being added
in patch levels (not even visible in the RUBY_VERSION constant) and major
version increments on special dates completely devoid of semantic relevance.</p>

<p>In Rubinius, we would like to provide a more sound versioning discipline, in
particular, semantic versioning. However, this raises some significant
challenges. Let’s consider some of the components of Rubinius:</p>

<ul>
  <li>Ruby language itself in one of three language modes: 1.8, 1.9, and 2.0</li>
  <li>Ruby core classes</li>
  <li>Ruby standard library</li>
  <li>MRI compatibility “C-API” for supporting C-extensions</li>
  <li>Supporting core classes like ByteArray and Tuple</li>
  <li>Bytecode compiler</li>
  <li>Virtual machine instruction set</li>
  <li>Internal APIs for JIT, garbage collection, concurrency management</li>
</ul>

<p>The key component on which semantic versioning is based is the public API. But
what is included in that? Is it just Ruby as covered in RubySpec? Is it also
our supporting Ruby classes or Ruby facilities like the parser and bytecode
compiler? Since Rubinius is a language platform used to implement other
programming languages besides Ruby, resolving these questions correctly is
important.</p>

<p>Along with a sound versioning discipline, we also want to promote continuous
delivery of enhancements to Rubinius. Technically, these are compatible goals,
but require that we consider how to organize our development and source
branches when we create backward-incompatible API changes.</p>

<p>As we work toward the Rubinius 2.0 release, we will do our best to implement
semantic versioning. You can help us by testing your applications, gems, or
libraries on Rubinius. One great place to do this, of course, is <a href="https://travis-ci.org/">Travis
CI</a>.</p>

<h2 id="all-work-and-no-play">All Work and No Play</h2>

<p>Portland is a beautiful city. It’s not very big but has enough city things to
feel like a proper city. I didn’t want to keep Dirkjan caged in the office all
day every day, so when the weather looked promising on Friday, we packed our
concurrency and garbage collection conversation up and headed out. First we
went to <a href="http://www.pdx.edu/">Portland State University</a> to attend a talk at a
programming language club. The talk was on continuation-passing style,
defunctionalization, and transformations. It was somewhat related to our
compiler work and it was certainly interesting. But my real motive was to
introduce Dirkjan to my former coworker <a href="https://twitter.com/larrytheliquid">Larry
Diehl</a>, who is a PhD student at PSU doing
fascinating work in dependently typed programming language theory.</p>

<p>After the talk at PSU, we hopped on the MAX light rail and headed toward the
<a href="http://japanesegarden.com/">Japanese Garden</a>. The bus that would take us the
rest of the way wasn’t due for 25 minutes so we decided to walk. The garden is
located in Portland’s <a href="http://washingtonparkpdx.org/">Washington Park</a>, which
is located in the west hills of Portland. So, we walked, uphill, for quite a
while. We walked past the Lewis and Clark monument, through the <a href="http://www.rosegardenstore.org/">international
rose garden</a>, past the tennis courts and
finally up another steep hill to the Japanese Garden.</p>

<p>The Japanese Garden is one of the most beautiful and authentic outside of
Japan. We are very lucky to have it here and my wife and I visit it frequently
to enjoy the beautiful views and bask in the tranquility. Since it is early
spring, not many plants were blossoming yet, but we saw some huge koi, some
water falls, beautiful trees, and a stunning view of Portland. Unfortunately,
Mt Hood was hiding in the clouds that day.</p>

<p>I’m not much of a photographer, but here are some pics from the trip.</p>

<p><img src="http://farm9.staticflickr.com/8516/8573161804_69e037f173_c.jpg" alt="Dirkjan photographing from a bridge" />
<img src="http://farm9.staticflickr.com/8367/8573160544_466e14d2ec_c.jpg" alt="Koi!" />
<img src="http://farm9.staticflickr.com/8378/8572067073_a0555e44bd_c.jpg" alt="Plants!" /></p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2013/03/13/welcome-dirkjan/" title="Welcome Dirkjan!" class="post_title">
        Welcome Dirkjan!
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Brian Shirai</span>
    <span class="date">13 March 2013</span>
    
      <a href="http://rubini.us/2013/03/13/welcome-dirkjan/#disqus_thread" data-disqus-identifier="/2013/03/13/welcome-dirkjan/"></a>

    
  </p>
</div>

      <p>I am excited to announce that <a href="https://engineyard.com">Engine Yard</a> is
sponsoring <a href="https://github.com/dbussink">Dirkjan Bussink</a> to work on Rubinius!</p>

<p>A long time ago (around 2008) when Dirkjan first showed up in the Rubinius
project he was still a university student finishing his Masters degree. He let
me read a draft of his thesis on brain-computer interfaces. Dirkjan has been
helping out on Rubinius since then. Recently, he’s been fixing concurrency,
garbage collection, and JIT issues.</p>

<p>This week, Dirkjan is working from the Engine Yard office in Portland, OR.
We’ve got a list of topics that we’re delving into to get ready for several
technology improvements in Rubinius. We started with a list of five things,
one for each day. Unfortunately, time always goes faster than we expect so
we’ve dropped one topic. I’ll blog a summary of our discussions so you get an
idea of some of the big stuff coming in Rubinius.</p>

<p>Our first discussion was about our inline cache mechanisms. An inline cache is
used at a method call location to speed up calling a method. The first time it
is called, the method is looked up. Subsequently, as long as the receiver is
the correct type, the same method can safely be used. This is a typical
execution-time versus memory size trade-off. We cache the method we found,
which saves time looking it up again at the expense of some additional memory
to store the method. As with all caches, we have to carefully consider cache
invalidation.  Let’s use a quick code sample to illustrate the inline cache.</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="k">class</span> <span class="nc">A</span>
<span class="lineno">2</span>   <span class="k">def</span> <span class="nf">a</span>
<span class="lineno">3</span>   <span class="k">end</span>
<span class="lineno">4</span> <span class="k">end</span>
<span class="lineno">5</span> 
<span class="lineno">6</span> <span class="k">class</span> <span class="nc">B</span> <span class="o">&lt;</span> <span class="n">A</span>
<span class="lineno">7</span> <span class="k">end</span>
</code></pre></div>

<p>In the example above, the class <code>B</code> inherits from <code>A</code>, which provides the method
<code>a</code>. If we call <code>a</code> on an instance of <code>B</code>, we look up the method and find it
in <code>A</code>.</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">new</span>
<span class="lineno">2</span> <span class="n">b</span><span class="o">.</span><span class="n">a</span>
</code></pre></div>

<p>Here, in the code representation for the call <code>b.a</code>, we store an inline cache
object. As long as the type of object we see in <code>b</code> is the same, we can safely
call the cached method <code>a</code>. However, if the type of <code>b</code> changes, for example,
because we define a method <code>a</code> on class <code>B</code> itself, we must invalidate the
cache and look up the method again.</p>

<p>The inline cache can be very important for the speed of the virtual machine
executing Ruby code. However, the inline cache is also very important for our
just-in-time (JIT) compiler that generates machine code, completely avoiding
the VM interpreter. Since the inline cache records the types of the Ruby
objects seen at the call site, we can use that information in the JIT to
generate fast code as long as our assumptions about the object type are
correct.</p>

<p>Since inline caches are so important, Dirkjan and I did a complete review of
our existing inline caching and analyzed how to improve it. The most important
thing for improving execution speed is to do less. And the best way to do less
is to reduce redundancy.</p>

<p>We started our analysis with an enumeration of all the kinds of calls that we
see in Ruby. This is the list that we made:</p>

<ul>
  <li>fixed-arity method send</li>
  <li>variadic method send</li>
  <li><code>respond_to?</code></li>
  <li><code>kind_of?</code></li>
  <li>fixed-arity <code>a.send</code></li>
  <li>variadic <code>a.send</code></li>
  <li><code>super</code> with explicit arguments</li>
  <li><code>super</code> with implicit arguments</li>
  <li><code>method_missing</code></li>
</ul>

<p>This list is all kinds of method sends that you can see directly in Ruby code.
We added to this list a few other things that are not in Ruby code:</p>

<ul>
  <li>extension API calls</li>
  <li>method combinations like <code>A.new</code> which reduces to <code>A.allocate.initialize</code></li>
  <li>call_custom (a special Rubinius instruction)</li>
  <li>primitives (parts of Ruby functionality that must be implemented in the VM)</li>
</ul>

<p>The next thing we did was look at the method call sites from the perspective
of the virtual machine. Certain method calls, like <code>respond_to?</code> imply certain
VM operations. This perspective is very important. Sometimes people complain
that Ruby is too dynamic because you could, for example, alias <code>respond_to?</code>
or <code>eval</code> to some other name. Now any attempt to statically analyze Ruby fails
because you can’t know ahead of time what the alias may be. This is actually
not an issue if you consider the perspective from the VM. No matter what the
method name is, the ultimate VM operation for looking up a method will
execute. By associating method call sites with a VM operation, we get more
insight into how best to structure the inline cache.</p>

<p>The next part of our analysis involved looking at what values are stored in
the inline cache for the various types we enumerated, and what values are used
for cache invalidation. The purpose of this analysis is two-fold: correctness
and performance. We want to ensure that our cache invalidation is correct
but also not generating false positives (i.e. invalidating cases that are not
actually invalid). We also want to ensure that storing and updating the data
in the cache can be done efficiently.</p>

<p>The final part of our analysis concerned the cardinality of the cache. In
object-oriented code, a method call site may be <em>monomorphic</em> (only one type
is seen), <em>polymorphic</em> (a small number of different types are seen), or
<em>megamorphic</em> (a huge number of different types are seen). This perspective
can be very important for performance and for memory overhead. We don’t want
to waste memory for sites that are monomorphic. Nor do we want the cache to be
thrashing when many different types are seen.</p>

<p>In summary, we looked at these aspects of inline caches: method call site
types, VM operations that result from the method call, the kind of data cached
and cache invalidation, and the cardinality of the method call site. We’ll be
taking the results of our discussion and implementing changes to our inline
caching over the next few weeks.</p>

<p>If you get a chance, pop into the #rubinius IRC channel on freenode.net and
say hello to Dirkjan!</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2013/02/26/heroku-cedar-rubinius-2-puma-2-in-three-easy-steps/" title="Heroku (Cedar) + Rubinius 2 + Puma 2 in Three Easy Steps" class="post_title">
        Heroku (Cedar) + Rubinius 2 + Puma 2 in Three Easy Steps
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Shane Becker</span>
    <span class="date">26 February 2013</span>
    
      <a href="http://rubini.us/2013/02/26/heroku-cedar-rubinius-2-puma-2-in-three-easy-steps/#disqus_thread" data-disqus-identifier="/2013/02/26/heroku-cedar-rubinius-2-puma-2-in-three-easy-steps/"></a>

    
  </p>
</div>

      <h3 id="tldr">tl;dr</h3>

<p>It’s now <strong><a href="https://github.com/rubinius/heroku-rbx-puma-rails-app">very easy</a></strong> to get a <a href="https://devcenter.heroku.com/articles/rails3">Rails app</a> on <a href="https://devcenter.heroku.com/articles/cedar">Heroku’s Cedar Stack</a> running on <a href="http://rubini.us" title="Rubinius : Use Ruby&#8482;">Rubinius 2.0</a> and <a href="http://puma.io" title="A Modern, Concurrent Web Server for Ruby - Puma">Puma 2.0</a>.</p>

<h3 id="the-backstory">The Backstory</h3>

<p>The fine folks at Heroku have been adding support for using <a href="http://gembundler.com" title="Bundler: The best way to manage a Ruby application's gems">Bundler</a> to <a href="https://devcenter.heroku.com/articles/ruby-versions">specify which version of Ruby</a> your app uses and even <a href="https://blog.heroku.com/archives/2012/12/13/run_jruby_on_heroku_right_now">to specify which Ruby</a> it uses.</p>

<p>I’ve checked in on the progress of using Rubinius with this same method every couple few months for the past year or so. I was always met with the same results… <q>“not quite yet, we’re working on it”</q>.</p>

<p>Last night I was getting mentally packed for <a href="https://waza.heroku.com/2013">Waza</a> later this week and decided to check in on the state of things so I could ask the right people the right questions in person when we’re all together. Turns out that sometime between last time and this time, they’ve got things working. Boom diggity! And it’s pretty ding-dang easy too! Double boom diggity!</p>

<h3 id="the-build-up">The Build Up</h3>

<p>I’m going to assume that if you want to use Rubinius 2.0 that you also have the good sense to want to use Puma 2.0. There are three very simple steps to get up and running with Rubinius 2.0 + Puma 2.0.</p>

<h4 id="step-1">Step 1</h4>

<p>Add the Puma gem to your <code>Gemfile</code>.</p>

<script src="https://gist.github.com/veganstraightedge/5041441.js"></script>

<h4 id="step-2">Step 2</h4>

<p>Tell Heroku to use Puma as your web server in your <code>Procfile</code>.</p>

<script src="https://gist.github.com/veganstraightedge/0135a61335bc76b1d9d5.js"></script>

<h4 id="step-3">Step 3</h4>

<p>Specify Rubinius as your Ruby engine in your <code>Gemfile</code>.</p>

<script src="https://gist.github.com/veganstraightedge/1fb7ff88e74567c6e2e6.js"></script>

<h3 id="the-breakdown">The Breakdown</h3>

<p>Once you’ve done those things, your workflow is the same as before.
<code>bundle update &amp;&amp; git commit -am "Double boom diggity!" &amp;&amp; git push heroku master</code></p>

<p>If you’re changing an existing app from Heroku’s default Ruby (MRI 1.9.x) to Rubinius, you’ll see a message like this when you <code>git push heroku master</code>.</p>

<script src="https://gist.github.com/veganstraightedge/5041986.js"></script>

<p>The important lines are <code>Old: ruby 1.9.3</code> and <code>New: rubinius 2.0.0.rc1</code>. After that, everything the same as before. The bundling starts, etc.</p>

<h3 id="the-outro">The Outro</h3>

<p>That’s it. You should now be up and running with Rubinius and Puma!</p>

<p>If you have problems, say something in the comments with a link to a gist with your problem output. If you succeed and get up and running in production, let us in the comments too. Tell the world that you love Rubinius/Puma.</p>

<p>I threw together this <a href="https://github.com/rubinius/heroku-rbx-puma-rails-app">quick and dirty Rails app</a> from scratch deployed to Heroku to show all this in action. <a href="http://heroku-rbx-puma-rails-app.herokuapp.com" title="Using Rubinius &amp; Puma on Heroku">http://heroku-rbx-puma-rails-app.herokuapp.com</a>. I also migrated an existing MRI 1.9.3 app ( <a href="http://farmhouse.la" title="The Farmhouse in Hollywood, California">The Farmhouse site</a> ) to Rubinius 2.0 to show the migration is easy too.</p>

<h3 id="the-thank-yous">The Thank Yous</h3>

<p>None of this would be possible without the hard work of <a href="https://github.com/carllerche">Carl Lerche</a>, <a href="https://github.com/wycats/">Yehuda Katz</a>, <a href="https://github.com/indirect/">André Arko</a>, <a href="https://github.com/hone">Terrence Lee</a> and the other contributors to <a href="https://github.com/carlhuda/bundler">Bundler</a>. And a special thanks to Terrence Lee for his dutiful stewardship of the <a href="https://github.com/heroku/heroku-buildpack-ruby/">Heroku Ruby Buildpack</a>. Once again, the awesome powers of Open Source make great things possible.</p>

<h3 id="the-footnotes">The Footnotes</h3>

<p>As of this writing “Rubinius 2.0” actually means “Rubinius 2.0.0.rc1” and “Puma 2.0” actually means “Puma 2.0.1”. The net result is the same though.</p>


    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2012/01/04/debugging-rubinius/" title="Debugging scary crashes of Rubinius" class="post_title">
        Debugging scary crashes of Rubinius
        </a>
      </h2>
      <div class="by_line">
  <p><span class="author">Dirkjan Bussink</span>
    <span class="date">04 January 2012</span>
    
      <a href="http://rubini.us/2012/01/04/debugging-rubinius/#disqus_thread" data-disqus-identifier="/2012/01/04/debugging-rubinius/"></a>

    
  </p>
</div>

      <p>Bugs, we all are in the infinite fight of getting rid of them. Sometimes
they are trivial, other times a bit harder. In this video I’m going to
show how I have been debugging an issue that caused memory corruption of
your dear Ruby objects in Rubinius.</p>

<h3 id="background">Background</h3>

<p>It’s a pretty long video clocking at 55 minutes but I’m trying to be
detailed in the discovery process. I’m explaining the steps I’m taking
along the way and explaining why I’m taking those.</p>

<p>The real debugging process if of course littered with taking wrong turns
so please don’t think I’m brilliant and able to zoom into the issue
immediately all the time. The video is not recorded as I was going
through it the first time, so I exactly knew where I was going and
which steps to take.</p>

<p>If you want to look up some more information on GDB that I’m using
in the video, here are some links that explain some of the most
used commands in the video:</p>

<p><a href="http://sourceware.org/gdb/onlinedocs/gdb/Data.html">GDB - Examining data</a>
<a href="http://sourceware.org/gdb/onlinedocs/gdb/Set-Watchpoints.html">GDB - Setting watchpoints</a></p>

<p>During the video there’s a part from 8:18 until 11:28 where it’s just
watching a rebuild of Rubinius scrolling by. I’d suggest skipping it
since it’s not very useful. I tried to remove it but after having
to reencode the video it only grew larger. If anyone has more skills
to fix that, please let us know!</p>

<h3 id="download">Download</h3>

<p>You can find the video on Vimeo:</p>

<p><a href="http://vimeo.com/34622441">Watch on Vimeo</a></p>

<p>It’s probably best to download the video and play it locally on your
machine. It’s 453 MB so it might take a while.</p>

<p>Please let us know if you find this useful, we might do more of them
in the future if there’s interest!</p>


    </div>
  
  </div>

<footer>
  <div class='container'>
    <nav>
      <ul>
        <li><a rel="external" href="http://twitter.com/rubinius">Follow Rubinius on Twitter</a></li>
        <li><a rel="external" href="http://github.com/rubinius/rubinius">Fork Rubinius on github</a></li>
        <li><a rel="external" href="http://engineyard.com">An Engine Yard project</a></li>
      </ul>
    </nav>
  </div>
</footer>

<script>
  var _gaq=[['_setAccount','UA-12328521-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>


<script>
  var disqus_shortname = 'rubinius';
  
  (function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  }());
</script>

  </body>
</html>
